<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///board and pieces
/*
In the main chess grid, each cell contains an array.
That array contains the info for that cell:

info.team: player the piece belongs to
            -1 = empty cell
            0 = 1st player
            1 = 2nd player
            
info.type: type of piece, enum "type"

---------------------------------

The system goes through 3 modes/states:

0 - Selecting a pawn
1 - Selecting a cell to move that pawn to
    -If can move there, proceed to mode 2
    -If can't move there, go back to mode 0
2 - Moving the pawn / Animating
    -When animation is done:
    -Change turn
    -Back to mode 0

*/

//board grid
board_w = 8; //number of cells in x
board_h = 8; //number of cells in y
board = ds_grid_create(board_w, board_h);

cell_size = 32; //size of each cell in pixels

//position
draw_x = 64; //where to draw the grid in the room
draw_y = 64; 

//properties of each cell
enum info{
    team,   //team it belongs to
    type  //type of piece, constants below
}

//types of pieces
enum type{
    empty,
    pawn,
    rook,
    knight,
    bishop,
    king,
    queen
}

//board sprites for customization
boards[0] = spr_board0;
boards[1] = spr_board1;
boards[2] = spr_board2;
boards[3] = spr_board3;
boards[4] = spr_board4;
boards[5] = spr_board5;

board_spr = 0; //current board sprite selected from the array above

//sprites &amp; colors
//sprite used for each piece type
sprites[type.pawn] = spr_pawn_white;
sprites[type.rook] = spr_rook_white;
sprites[type.knight] = spr_knight_white;
sprites[type.bishop] = spr_bishop_white;
sprites[type.king] = spr_king_white;
sprites[type.queen] = spr_queen_white;

//color of the teams' pieces
colors[0] = c_white;
colors[1] = c_black;

//fill empty
//create an array with properties of an empty cell
//fill grid with that array
var _empty;
_empty[info.team] = -1;
_empty[info.type] = type.empty;

ds_grid_set_region(board, 0, 0, board_w-1, board_h-1, array_new(_empty));

//place pawns
//pawn array
var _pawn;
_pawn[info.type] = type.pawn; //set type to type.pawn
//loop through horizontal cells
for(var i=0; i&lt;board_w; i++){
    //place pawns for player 1
    _pawn[info.team] = 0;
    ds_grid_set(board, i, 1, array_new(_pawn));
    //place pawns for player 2
    _pawn[info.team] = 1;
    ds_grid_set(board, i, board_h - 2, array_new(_pawn));
}

//place other pieces
var _array;

//place rooks
_array[info.type] = type.rook;
_array[info.team] = 0;
ds_grid_set(board, 0, 0, array_new(_array));
ds_grid_set(board, board_w - 1, 0, array_new(_array));
_array[info.team] = 1;
ds_grid_set(board, 0, board_h - 1, array_new(_array));
ds_grid_set(board, board_w - 1, board_h - 1, array_new(_array));

//place knights
_array[info.type] = type.knight;
_array[info.team] = 0;
ds_grid_set(board, 1, 0, array_new(_array));
ds_grid_set(board, board_w - 2, 0, array_new(_array));
_array[info.team] = 1;
ds_grid_set(board, 1, board_h - 1, array_new(_array));
ds_grid_set(board, board_w - 2, board_h - 1, array_new(_array));

//place bishops
_array[info.type] = type.bishop;
_array[info.team] = 0;
ds_grid_set(board, 2, 0, array_new(_array));
ds_grid_set(board, board_w - 3, 0, array_new(_array));
_array[info.team] = 1;
ds_grid_set(board, 2, board_h - 1, array_new(_array));
ds_grid_set(board, board_w - 3, board_h - 1, array_new(_array));

//place queen
_array[info.type] = type.queen;
_array[info.team] = 0;
ds_grid_set(board, 3, 0, array_new(_array));
_array[info.team] = 1;
ds_grid_set(board, 3, board_h - 1, array_new(_array));

//place king
_array[info.type] = type.king;
_array[info.team] = 0;
ds_grid_set(board, 4, 0, array_new(_array));
_array[info.team] = 1;
ds_grid_set(board, 4, board_h - 1, array_new(_array));




</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///game
randomize();

//font
draw_set_font(ft_chess);

//turns &amp; modes
turn = choose(0, 1); //Which player's turn is it? Choose randomly for a start.
mode = 0; //mode/state:
            //0 - selecting a piece
            //1 - selecting a cell to move that piece to
            //2 - moving that piece

//win
win = -1; //Who won? 0 if player one, 1 if player two. -1 if game not over yet

//selected
sel_type = type.empty; //which type of piece is selected?
sel_x = 0; //what is the position of the selected cell?
sel_y = 0;

//lost
lost[0] = ds_list_create(); //lost pieces by player 1
lost[1] = ds_list_create(); //lost pieces by player 2
                            //only ded bois in this list. lol

//check
check[0] = false; //is player 1 in check?
check[1] = false; //is played 2 in check?

checking_x = 0; //which cell is being checked?
checking_y = 0;

checked_x = 0; //which cell has been checked?
checked_y = 0;

check_show = false; //whether check is being drawn

//mouse cell position inside board
cell_x = 0;
cell_y = 0;

mouse_out = false; //whether mouse is outside the board/grid

//where to move the piece
move_x = 0;
move_y = 0;


//moveable grid
//this grid sets the cells where the piece can move to true, others to false
//used to check whether a piece can move or not
moveable = ds_grid_create(board_w, board_h);
ds_grid_set_region(moveable, 0, 0, board_w-1, board_h-1, false);

//colors
moveable_color = c_lime;
select_color = c_aqua;
cursor_color_team = c_yellow;
cursor_color_simple = c_white;
check_color = c_red;

//animation
animated = false;

anim_x = 0;
anim_y = 0;

anim_speed = 0.3;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///disable check show
check_show = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///game
//exit if won
if (win!=-1){  
    //game restart on click
    if (mouse_check_button_pressed(mb_left)) room_restart();
    
    exit;
}

//mouse position
cell_x = (mouse_x - draw_x) div cell_size;
cell_y = (mouse_y - draw_y) div cell_size;

//mouse out of board
mouse_out = cell_x &lt; 0 || cell_y &lt; 0 || cell_x &gt;= board_w || cell_y &gt;= board_h;

//after animation complete
if (mode==2 &amp;&amp; animated){
    //get move piece
    var _move_ar = board[# move_x, move_y];
    var _move_team = _move_ar[info.team];
    //defeat if enemy present
    if (_move_team==!turn) defeat_piece(move_x, move_y);
    //move piece
    board_set_cell(board, move_x, move_y, turn, sel_type);
    board_set_cell(board, sel_x, sel_y, -1, type.empty);
    //clear moveable grid after checking
    check[!turn] = false;
    moveable_check(moveable, move_x, move_y, board, sel_type);
    moveable_clear();
    //change turn
    turn = !turn;
    mode = 0;
    //if check, check if the other side is lost
    if (check[turn]){
        //vars to check their loss
        var can_be_defeated = false;
        var king_can_move = false;
        //apply all_moveable grid to check if the current piece can be defeated
        var all_moveable = ds_grid_create(board_w, board_h);
        for(var _h=0; _h&lt;board_h; _h++){
            for(var _w=0; _w&lt;board_w; _w++){
                //get array
                var _ar = board[# _w, _h];
                var _team = _ar[info.team];
                var _type = _ar[info.type];
                
                //check
                if (_team==turn){
                    moveable_check(all_moveable, _w, _h, board, _type);
                }
            }
        }
        //check if piece can be defeated
        can_be_defeated = all_moveable[# move_x, move_y];
        //destroy grid
        ds_grid_destroy(all_moveable);
        //--------check if king can move somewhere---------
        //get all possible moves of the opponent
        turn = !turn;
        
        all_moveable = ds_grid_create(board_w, board_h);
        
        var all_moveable = ds_grid_create(board_w, board_h);
        for(var _h=0; _h&lt;board_h; _h++){
            for(var _w=0; _w&lt;board_w; _w++){
                //get array
                var _ar = board[# _w, _h];
                var _team = _ar[info.team];
                var _type = _ar[info.type];
                
                //check
                if (_team==turn){
                    moveable_check(all_moveable, _w, _h, board, _type);
                }
            }
        }
        
        turn = !turn;
        
        //get king position
        var king_x = -1, king_y = -1;
        
        for(var _h=0; _h&lt;board_h; _h++){
            for(var _w=0; _w&lt;board_w; _w++){
                //get array
                var _ar = board[# _w, _h];
                var _team = _ar[info.team];
                var _type = _ar[info.type];
                
                if (_type==type.king &amp;&amp; _team==turn){
                    king_x = _w;
                    king_y = _h;
                    break;
                }
            }
            if (king_x!=-1) break;
        }
        
        //loop through all 8 directional movements
        for(var _yy = -1; _yy &lt;= 1; _yy++){
            for(var _xx = -1; _xx &lt;= 1; _xx++){
                //check if out of bounds
                var out_bound = false;
                if (king_x+_xx &lt; 0 || king_x+_xx &gt;= board_w || king_y+_yy &lt; 0 || king_y+_yy &gt;= board_h) out_bound = true;
                if (!out_bound){
                    //if no one can move there
                    if (!all_moveable[# king_x + _xx, king_y + _yy]) king_can_move = true;
                    //if king can move there, check for friendly pieces
                    if (king_can_move){
                        //get array
                        var _ar = board[# king_x + _xx, king_y + _yy];
                        var _team = _ar[info.team];
                        var _type = _ar[info.type];
                        
                        if (_team==turn) king_can_move = false;
                        
                        //break if king can move
                        if (king_can_move) break;
                    }
                }
            }
            if (king_can_move) break;
        }
        
        //check if the player has any chances
        if (!king_can_move &amp;&amp; !can_be_defeated){
            win = !turn;
            audio_play_sound(snd_win, 10, false);
            check_show = true;
        }
        
        //check
        check[turn] = true;
    }
}

//exit if mouse out of board
if (mouse_out) exit;

//get board cell
var _array, _type, _team;
_array = board[# cell_x, cell_y];
_team = _array[info.team];
_type = _array[info.type];

//if clicked
if (mouse_check_button_pressed(mb_left)){
    //select mode (0)
    if (mode==0 &amp;&amp; _team==turn){
        //select piece
        sel_type = _type;
        sel_x = cell_x;
        sel_y = cell_y;
        mode = 1;
        //check moveables
        moveable_clear();
        moveable_check(moveable, sel_x, sel_y, board, sel_type);
        //sound
        audio_play_sound(snd_choose, 10, false);
    }
    //move mode (1)
    else if (mode==1){
        //check for checks from the other side
        check[turn] = false;
        
        //future board
        var future_board = ds_grid_create(board_w, board_h);
        ds_grid_copy(future_board, board);
        
        board_set_cell(future_board, sel_x, sel_y, -1, type.empty);
        board_set_cell(future_board, cell_x, cell_y, turn, sel_type);
        
        //check all pieces for 
        turn = !turn;
        for(var _h=0; _h&lt;board_h; _h++){
            for(var _w=0; _w&lt;board_w; _w++){
                //get array
                var _ar = future_board[# _w, _h];
                var _team = _ar[info.team];
                var _type = _ar[info.type];
                
                //check
                if (_team==turn){
                    var temp_grid = ds_grid_create(board_w, board_h);
                    moveable_check(temp_grid, _w, _h, future_board, _type);
                    ds_grid_destroy(temp_grid);
                }
                if (check[!turn]) break;
            }
            if (check[!turn]) break;
        }
        turn = !turn;
        
        ds_grid_destroy(future_board);
        //cancel move
        if ((cell_x==sel_x &amp;&amp; cell_y==sel_y) || check[turn]){
            mode--;
            audio_play_sound(snd_cancel, 8, false);
            
            //check show
            if (check[turn]){
                check_show = true;
                alarm[0] = 30;
            }
            
            //disable check
            check[turn] = false;
            
            //recheck check
            moveable_check(moveable, sel_x, sel_y, board, sel_type);
        }
        //register move
        else if (moveable[# cell_x, cell_y]){
            //set moving position
            move_x = cell_x;
            move_y = cell_y;
            
            //set animation position
            anim_x = draw_x + sel_x*cell_size;
            anim_y = draw_y + sel_y*cell_size;
            
            animated = false;
            
            //change mode
            mode = 2;
            
            //sound
            audio_play_sound(snd_move, 10, false);
            audio_play_sound(snd_drag, 8, false);
        }
    }
}
    
    
    
    
    
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw board
//debug
//draw_text(5, 5, check[0]);
//draw_text(5, 20, check[1]);

//draw board
draw_sprite(boards[board_spr], 0, draw_x, draw_y);

//mouse highlight
if (!mouse_out &amp;&amp; win==-1){
    //get board cell
    var _array, _type, _team;
    _array = board[# cell_x, cell_y];
    _team = _array[info.team];
    _type = _array[info.type];
    
    //draw mouse cell
    var _xx = draw_x + (cell_x*cell_size);
    var _yy = draw_y + (cell_y*cell_size);
    
    if (_team==turn){
        draw_highlight(_xx, _yy, cursor_color_team);
    }else{
        draw_highlight(_xx, _yy, cursor_color_simple);
    }
}

//draw check show
if (check_show){
    draw_highlight(checking_x, checking_y, check_color);
    draw_highlight(checked_x, checked_y, check_color);
}


//draw pieces
for(var h=0; h&lt;board_h; h++){
    for(var w=0; w&lt;board_w; w++){
        //get cell type
        var _arr = board[# w, h];
        var _type = _arr[info.type];
        var _team = _arr[info.team];
        //set position to draw cell in pixels
        var _xx = draw_x + (w*cell_size);
        var _yy = draw_y + (h*cell_size);
        //check if it is being moved
        var _moved = mode==2 &amp;&amp; sel_x==w &amp;&amp; sel_y==h;
        //draw moveable cells in move mode
        if (mode==1 &amp;&amp; moveable[# w, h]){
            draw_highlight(_xx, _yy, moveable_color);
        }
        //draw selected
        if (mode==1 &amp;&amp; sel_x==w &amp;&amp; sel_y==h){
            draw_highlight(_xx, _yy, select_color);
        }
        //if not empty, draw piece
        if (_type!=type.empty &amp;&amp; !_moved){
            draw_sprite_ext(sprites[_type], 0, _xx, _yy, 1, 1, 0, colors[_team], 1);
        }
    }
}

//draw move animation
if (mode==2){
    //move x/y
    var _move_px = draw_x + cell_size*move_x;
    var _move_py = draw_y + cell_size*move_y;
    
    //draw sprite
    draw_sprite_ext(sprites[sel_type], 0, anim_x, anim_y, 1, 1, 0, colors[turn], 1);
    
    //movement x/y
    //var _xx = _move_px - anim_x;
    //var _yy = _move_py - anim_y;
    
    //animate
    anim_x = lerp(anim_x, _move_px, anim_speed);
    anim_y = lerp(anim_y, _move_py, anim_speed);
    
    //set animated false
    if (point_distance(anim_x, anim_y, _move_px, _move_py)&lt;=1) animated = true;
}

//draw lost pieces
var lost_size = 0.5;
var lost_draw_marg = cell_size * lost_size;

//0 team
for(var i=0; i&lt;ds_list_size(lost[0]); i++){
    //get lost array
    var _list = lost[0];
    var _lost = _list[| i];
    var _lost_type = _lost[info.type];
    
    draw_sprite_ext(sprites[_lost_type], 0, draw_x - lost_draw_marg, draw_y + lost_draw_marg*i, lost_size, lost_size, 0, -1, 1);
}

//1 team
for(var i=0; i&lt;ds_list_size(lost[1]); i++){
    //get lost array
    var _list = lost[1];
    var _lost = _list[| i];
    var _lost_type = _lost[info.type];
    
    draw_sprite_ext(sprites[_lost_type], 0, draw_x + cell_size*board_w, draw_y + lost_draw_marg*i, lost_size, lost_size, 0, c_black, 1);
}

//draw turn
var marg = 24;

if (win==-1){
    if (turn==0){
        draw_text_center(draw_x + (board_w*cell_size)/2, draw_y - marg, "White's Turn", 1, 1, 0, c_white, 1);
    }
    else if (turn==1){
        draw_text_center(draw_x + (board_w*cell_size)/2, draw_y + (board_h*cell_size) + marg, "Black's Turn", 1, 1, 0, c_black, 1);
    }
}

//draw won
if (win==0){
    draw_text_center(draw_x + (board_w*cell_size)/2, draw_y - marg, "White Won!", 1, 1, 0, c_white, 1);
}
else if (win==1){
    draw_text_center(draw_x + (board_w*cell_size)/2, draw_y + (board_h*cell_size) + marg, "Black Won!", 1, 1, 0, c_black, 1);
}

//draw check text
if (win==-1){
    if (check[0]){
        draw_text_center(draw_x + (board_w*cell_size)/2, draw_y - 8, "White is in check!", 0.7, 0.7, 0, c_white, 1);
    }
    else if (check[1]){
        draw_text_center(draw_x + (board_w*cell_size)/2, draw_y + (board_h*cell_size) + 8, "Black is in check!", 0.7, 0.7, 0, c_black, 1);
    }
}

//click to play again
if (win!=-1){
    draw_text_transformed(5, 5, "Click to play again", 0.7, 0.7, 0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
